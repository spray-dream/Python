{"./":{"url":"./","title":"Introduction","keywords":"","body":"课程内容 天数 内容 1 测试用例的设计 1 缺陷和缺陷报告 学习目标 知道测试用例的作用 能够说出测试用例的构成 能够说出各种测试用例设计思想的本质 知道缺陷报告的作用 能说出缺陷报告的内容 能够正确书写缺陷报告 © 2021 测试猿-猫熊 all right reserved，powered by Gitbook本文档更新于： 2021-04 "},"C4.S0.target.html":{"url":"C4.S0.target.html","title":"测试用例","keywords":"","body":"学习目标 知道测试用例的作用 能够说出测试用例的构成 能够说出各种测试用例设计思想的本质 © 2021 测试猿-猫熊 all right reserved，powered by Gitbook本文档更新于： 2021-04 "},"C4.S1.basic_concept.html":{"url":"C4.S1.basic_concept.html","title":"基础概念","keywords":"","body":"测试用例 概念 测试用例定义 测试用例又叫做test case，是为某个特殊目标而编制的一组测试输入、执行条件以及预期结果,以便测试某个程序路径或核实是否满足某个特定需求。 测试用例的特性 有效性 测试用例的能够被使用，且被不同人员使用测试结果一致。 可复用性 良好的测试用例具有重复使用的功能，如：回归测试 易组织性 好的测试用例会分门别类地提供给测试人员参考和使用。 可评估性 从测试管理的角度，测试用例的通过率和软件缺陷的数目是软件产品质量好坏的测试标准。 可管理性 从测试管理的角度，测试用例的通过率和软件缺陷的数目是软件产品质量好坏的测试标准。 测试用例的要素 测试用例编号 测试项目(测试模块) 预置(前提)条件 测试输入 预期输出 操作步骤 测试用例标题 级别 ST-子项名-01 手机登录 手机正常使用 手机号 正常登录 输入手机号并确认 测试能否手机登录成功 重要 测试用例八大要素 测试用例编号 编号由字符和数字组合成的字符串,用例编号具有唯一性、容易识别, 如下表 测试项目/模块 测试的项目属于哪个项目或者被测试的需求、被测的模块、被测的单元等等 预置条件 执行当前测试用例需要的前提条件,如果前提条件不满足,则后面的测试步骤不能进行或者得不到预期结果 测试输入 测试用例执行过程中需要加工的外部信息.根据测试用例的具体条件有手工输入、数据库等 预期输出 测试用例的预期输出结果,包括返回值内容、界面响应结果等. 操作步骤 执行当前测试用例需要经过的操作步骤，需要明确的给出一个步骤的描述，测试用例执行人员可以根据该步骤完成测试用例执行 测试用例标题 对测试用例的简单描述。用概括的语言描述该测试用例的测试点。每个测试用例的标题不能够重复，因为每个测试用例的测试点事不一样的。 级别 对于测试用例的重要程度的区分.包含如下几种: 高级别：保证系统基本功能、核心业务、重要特性、实际使用频率比较高的用例 中级别：重要程度介于高和低之间的测试用例 低级别：实际使用的频率不高，对系统业务功能影响不大的模块或功能的测试用例 其他要素 用例的设计者:能准确找到测试用例的设计人员,对用例修改时能方便找到人员 用例设计日期: 方便检查用例的设计进度 对应的开发人员: 出现bug后能及时找到相应的人员进行修复 测试结果: 执行用例最后执行的结果, 包括:pass、fail、block 测试类型: 功能、性能、压力等等 测试用例的设计原则 明确性 测试人员要尽量避免测试用例存在含糊的因素，在测试过程中，测试用例的测试结果是唯一的。 代表性 尽量将具有相似功能的测试用例抽象合并，功能相似的用例要合并。 简洁性 测试用例简洁，可读性良好，测试过程目的明确，测试结果唯一。 测试用例要用陈述性语句 一句话直指问题的核心 ,不要使用浮夸的修饰手法 小结 测试用例要素是为了便于我们快速的设计测试用例,因此要掌握最常用的八大要素, 但是每家公司的具体要求不一样,要根据公司要求灵活添加测试的元素. © 2021 测试猿-猫熊 all right reserved，powered by Gitbook本文档更新于： 2021-04 "},"C4.S2.equivalent.html":{"url":"C4.S2.equivalent.html","title":"等价类划分法","keywords":"","body":"等价类划分法 官方定义: 等价类测试方法是把所有可能的输入数据，即程序的输入域划分成若干部分，然后从每一部分中选取少数有代表性的数据作为测试用例。使用等价类划分方法设计测试用例要经历划分等价类（列出等价类表）和选取测试用例两步。它将不能穷举的测试过程进行合理分类，从而保证设计出来的测试用例具有完整性和代表性。 等价类划分 在测试中最完美的测试是使用穷举测试,把所有的数据都测一遍.但是实际工作中不能采用,因为效率太低了. 理想的测试时:使用最少的测试数据,达到最好的测试质量. 合理假设 测试某等价类的代表值就等于对这一类其它值的测试。 类型划分 有效等价类 有效等价类是指对对于程序的规格说明来说是合理的、有意义的输入数据构成的集合.利用有效等价类可检验程序是否实现了规格说明中所规定的功能和性能. 无效等价类 无效等价类指对程序的规格说明是不合理的、无意义的输入数据所构成的集合。对于具体的问题，无效等价类至少应有一个，也可能有多个。利用无效等价类可校验程序对于无效数据的处理能力,检测程序的健壮性、容错能力 等价类 等价类是指某个输入域的子集合。在该子集合中，各个输入数据对于揭露程序中的错误都是等效的，具有等价特性。 注意 设计测试用例时,要同时考虑这两种等价类。因为软件不仅要能接收合理的数据,也要能经受意外的考验，这样的测试才能确保软件具有更高的可靠性。 设计测试用例步骤 确定需求 确定有效等价类和无效等价类 对每条等价类设计测试用例 案例 qq登录 © 2021 测试猿-猫熊 all right reserved，powered by Gitbook本文档更新于： 2021-04 "},"C4.S3.boundary.html":{"url":"C4.S3.boundary.html","title":"边界值","keywords":"","body":"边界值法 介绍 边界值分析法就是对输入或输出边界值进行测试的,也是一种黑盒测试. 边界值分析法通常作为等价类划分法的补充,其测试用例来自等价类的边界; 长期的经验得知,大量的错误是发现在输入或输出范围的边界上，而不是发生再输入输出范围的内部，因此针对各种边界情况设计测试用例，可以查出更多错误. 等价类划分法的区别: 等价类划分法可以挑选等价范围内任意一个数据作为代表 边界值分析法要求每个边界值都要作为测试条件 边界值分析法不仅考虑输入条件,同样考虑输出产生的测试情况 常见的边界值 边界点(上点) 输入范围的边界点 离点 离边界点最近的点 内点 输入范围内的任意一个点 步骤: 明确需求 确定有效和无效等价类 明确输入条件中的边界值 编写测试用例 案例 计算器 © 2021 测试猿-猫熊 all right reserved，powered by Gitbook本文档更新于： 2021-04 "},"C4.S4.causal.html":{"url":"C4.S4.causal.html","title":"因果图","keywords":"","body":"因果图法 定义 因果图法是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法， 它适合于检查程序输入条件的各种组合情况 特点： 考虑输入条件的相互制约及组合关系 考虑输出条件对输入条件的依赖关系 背景 等价类划分法和边界值分析法都是着重考虑输入条件，但没有考虑输入条件的各种组合，输入条件之间的相互制约关系，这样虽然各种输入条件可能出错的情况已经测试到了，但多个输入条件组合起来可能出错的情况却被忽视了。 如果在测试时必须考虑输入条件的各种组合，则可能的组合数目将是天文数字，因此必须考虑采用一种适合于描述多种条件的组合，相应产生多个动作的形式来进行测试用例的设计，这就需要利用因果图（逻辑模型）。 核心 因果图法比较合适输入条件比较多的情况，测试所有的输入条件的排列组合，所谓的原因就是输入，所谓的结果就是输出。 \"因\"= 输入条件 \"果\"= 输出结果 主要考虑内容 所有输入/输出条件的相互制约关系以及组合关系 输入条件的依赖关系，也就是什么样的输入组合会产生怎么样的输出结果，即\"因果关系\" 因果图中的符号 基本符号 通常在因果图中用Ci表示原因，用Ei表示结果，各结点表示状态，可取值‘0’或‘1’。‘0’表示某状态不出现‘1‘表示某状态出现。 约束条件 E(exclude) 约束: a和b中至多有一个为1. I(include) 包含: a、b和c中至少有一个必须是1. M(mandatory) 强制: 若结果a是1,结果b强制为0. O(only) 唯一: a和b必须有一个，且仅有1个为1. R(required) 要求: a是1时，b必须是1. 因果图法基本步骤 找出所有的原因，原因即输入条件或输入条件的等价类。 找出所有的结果，结果即输出条件。 明确所有输入条件之间的制约关系以及组合关系。 哪些条件不能组合到一起，哪些条件可以组合到一起 明确所有输出条件之间的制约关系以及组合关系。 哪些输出结果不能同时输出，哪些输出结果可以同时输出 找出什么样的输入条件组合会产生哪种输出结果。 把因果图转换成判定表/决策表。 为判定表/决策表中的每一列表示的情况设计测试用例。 案例：交通一卡通自动充值软件 系统需求 系统只接收50或100元纸币，一次只能使用一张纸币，一次充值金额只能为50元或100元； 若输入50元纸币，并选择充值50元，完成充值后退卡，提示充值成功； 若输入50元纸币，并选择充值100元，提示输入金额不足，并退回50元； 若输入100元纸币，并选择充值50元，完成充值后退卡，提示充值成功，找零50元； 若输入100元纸币，并选择充值100元，完成充值后退卡，提示充值成功； 若输入纸币后在规定时间内不选择充值按钮，退回输入的纸币，并提示错误； 若选择充值按钮后不输入纸币，提示错误 实现步骤 https://blog.csdn.net/weixin_43090420/article/details/90608526 © 2021 测试猿-猫熊 all right reserved，powered by Gitbook本文档更新于： 2021-04 "},"C4.S5.decision.html":{"url":"C4.S5.decision.html","title":"判定表","keywords":"","body":"判定表法 定义 判定表也称决策表, 是分析和表达多逻辑条件下执行不同操作的工具。 它能够将复杂的问题按照各种可能的情况全部列举出来，简明并避免遗漏。 因此,利用判定表能够设计出完整的测试用例集合。 在一些数据处理问题当中，某些操作的实施依赖于多个逻辑条件的组合， 即：针对不同逻辑条件的组合值，分别执行不同的操作。判定表适合于处理这类问题。 使用场景 适合于有多个输入和对个输出,输入和输出之间有相互的组合关系, 输入输出之间有相互的制约和依赖关系 组成 判定表是由条件桩、动作桩、条件项、动作项四部分组成,如下图. 条件桩（Condition Stub）： 列出了问题得所有条件。通常认为列出的条件的次序无关紧要。 动作桩（Action Stub）： 列出了问题规定可能采取的操作。这些操作的排列顺序没有约束。 条件项（Condition Entry）： 列出针对它左列条件的取值。在所有可能情况下的真假值。 动作项（Action Entry）： 列出在条件项的各种取值情况下应该采取的动作。 规则 任何一个条件组合的特定取值及其相应要执行的操作称为规则。 在判定表中贯穿条件项和动作项的一列就是一条规则。显然判定表中列出多少组条件取值，也就有多少条规则，既条件项和动作项有多少列。 化简 规则合并有两条或多条规则具有相同动作,并且其条件项之间存在着极为相似的关系。 步骤 明确规则个数 列出所有条件桩和动作桩 填入条件项 填入动作项到初始判定表 简化,合并相似规则 案例1: 公交卡充值 案例2：维修设备 问题要求 对于功率大于50马力的机器且维修记录不全 或 运行10年以上的机器,应优先维修. 优缺点 优点 能把复杂问题按照各种可能情况—列举出来, 简明而易于理解,避免遗漏 缺点 不能表达重复执行的动作、例如循环结构 © 2021 测试猿-猫熊 all right reserved，powered by Gitbook本文档更新于： 2021-04 "},"C4.S6.orthogonal.html":{"url":"C4.S6.orthogonal.html","title":"正交表","keywords":"","body":"正交表法 定义 正交法,也叫正交实验法或者正交排列法, 就是使用最小的测试过程集合获得最大的测试覆盖率。 \"正交实验\"是研究多因素、多水平的一种实验方法,它利用正交表来对实验进行设计,通过少数实验代替全面的实验。 在一项实验中,把影响试验结果的量称为试验因素(因子)，简称因素。因素可以理解为试验过程中的自变量，试验结果可以看成因素的函数。 在试验过程中，每一个因素可以处于不同的状态或状况，把因素所处的状态或状况，称为因素的水平，简称水平。 历史案例 1992年AT&T公司,针对某一个软件做了一个回归测试： 在18个周（4个半月）的时间范围内测试1500条测试用例。后来开发时间推迟了，测试时间被压缩了。测试经理想了一个办法，两个人在8个周（2个月）测试1000条测试用例。但是测试经理不能保证该软件就是完全没有问题的。后来他决定用正交表去重新设计一下测试用例，422条测试用例，42个bug。测试完毕后，软件上线了。在上线的两年时间内。凡事被测试到的领域，都没有发现任何问题。后来呢，他从头到尾有总结了一番：有可能只会测试出32条bug。 前后对比： 测试用例的条数少了 测试出来bug的数量多了 正交表的构成 要点 所有组合中，只要任意两个因素间 进行了全排列即可。 步骤 根据需求把空间即其取值列举出来 根据空间和空间的取值个数,选择一个合适的正交表 根据控件的个数,选择正交表的次幂,也就是正交表中包含的最大值, 例如,4个控件,选择4次幂 根据控件取值个数,选择正交表的底,也就是正交表包含的最大值, 例如, 每个控件有3个取值,底是3 把控件及其取值映射到正交表中 把控件名字分别映射到正交表的列名位置 把正交表中每一列的数字分别用对应的控件取值替代 根据正交表,编写测试用例 案例 实现\"字符属性设置\"的测试用例编写 | 字体 | 字符样式 | 字体颜色 | 字号 | | :------: | :------: | :------: | :--: | | 仿宋 | 粗体 | 红色 | 20号 | | 楷体 | 斜体 | 绿色 | 30号 | | 华文彩云 | 下划线 | 蓝色 | 40号 | allpairs工具的使用 利用Excel准备一个表格 将表格内容贴到txt文本中，并保存 通过allpairs 命令生成 拷贝结果到测试用例中 使用场景 需求中条件的组合量比较大的时候 需求两个两个相互组合的时候 © 2021 测试猿-猫熊 all right reserved，powered by Gitbook本文档更新于： 2021-04 "},"C4.S7.scenarios.html":{"url":"C4.S7.scenarios.html","title":"场景法","keywords":"","body":"场景法 定义 从起点，通过一系列操作步骤（事件），达成某一结果，到终点的过程测试。 场景法主要用于冒烟测试。在通过了场景测试后，再通过其他方法进行更为细腻的测试。 概念及定义 现在的软件几乎都是由事件触发来控制流程的， 事件触发时的情景便形成了场景， 而同一事件不同的触发顺序和处理结果形成事件流。 要素 下图中经过用例的每条不同路径都反映了基本流和备选流，都用箭头来表示。基本流用直黑线来表示，是经过用例的最简单的路径。每个备选流自基本流开始，之后，备选流会在某个特定条件下执行。备选流可能会重新加入基本流中（备选流 1 和 3），还可能起源于另一个备选流（备选流 2），或者终止用例而不再重新加入某个流（备选流 2 和 4）。 说明 遵循上图中每个经过用例的可能路径，可以确定不同的用例场景。从基本流开始，再将基本流和备选流结合起来，可以确定以下用例场景： 场景 1 基本流 场景 2 基本流 备选流 1 场景 3 基本流 备选流 1 备选流 2 场景 4 基本流 备选流 3 场景 5 基本流 备选流 3 备选流 1 场景 6 基本流 备选流 3 备选流 1 备选流 2 场景 7 基本流 备选流 4 场景 8 基本流 备选流 3 备选流 4 注：为方便起见，场景 5、6 和 8 只描述了备选流 3 指示的循环执行一次的情况。 例子（语音通话） https://www.cnblogs.com/vmorgen/p/6862115.html © 2021 测试猿-猫熊 all right reserved，powered by Gitbook本文档更新于： 2021-04 "},"C4.S8.process.html":{"url":"C4.S8.process.html","title":"流程分析","keywords":"","body":"流程分析法 由来 流程分析法主要是针对测试场景类型属于流程测试场景的测试项下的测试子项进行设计，是从白盒测试设计方法中的路径覆盖分析法借鉴过来的一种方法。 在白盒测试中，路径就是指函数代码的某个分支组合，路径覆盖法需要构造足够的用例覆盖函数的所有代码路径。 路径覆盖法: 把所有测试条件写成测试用例,白盒是根据代码分支分析写测试用例 在黑盒测试中，若将软件系统的某个流程看成路径的话，则可以针对该路径使用路径分析的方法设计测试用例。 黑盒测试是看文档来写测试用例,不需要看代码 步骤: 详细了解需求； 根据需求说明或界面原型，找出业务流程的各个页面以及各页面之间的流转关系； 画出业务流程； 写用例，覆盖所有的路径分支。 案例-ATM ATM机功能 绘制出可达矩阵 使用深度或者广度法进行遍历 写测试用例 使用场景 一般用于测试非常重要的系统（ATM机、医疗设备） © 2021 测试猿-猫熊 all right reserved，powered by Gitbook本文档更新于： 2021-04 "},"C4.S9.intuition.html":{"url":"C4.S9.intuition.html","title":"错误推断法","keywords":"","body":"错误推断法 定义 错误推测法是: 基于经验和直觉推测程序中所有可能存在的各种错误，从而有针对性的设计测试用例的方法。 基本思想 根据经验,列举出程序中所有可能有的错误和容易发生错误的特殊情况,根据他们选择测试用例。 使用场景 适用于项目时间比较短促，任务比较繁重的情况下，而且测试经验较多。 © 2021 测试猿-猫熊 all right reserved，powered by Gitbook本文档更新于： 2021-04 "},"C4.S10.strength.html":{"url":"C4.S10.strength.html","title":"测试力度","keywords":"","body":"测试用例的力度 简单 仅仅试测试的纲要，可能只包含测试的内容。 简单的测试用例其实并没有进行\"设计\"，而仅仅是记录。只是提醒测试人员主要功能有哪些。 复杂 包含具体的输入项、每一个步骤、期待的结果。 中庸 过于简单，会导致测试有遗漏，而且根据测试执行人员的水平不同导致偏差较大。 过于复杂，会导致效率太低，维护成本太高，限制测试人员的思维 一般在工作中都介于两者之间 © 2021 测试猿-猫熊 all right reserved，powered by Gitbook本文档更新于： 2021-04 "},"C4.S11.summary.html":{"url":"C4.S11.summary.html","title":"总结","keywords":"","body":"测试用例设计方法总结 测试用例的本质（基于需求） 理解需求、反映需求，忠于需求 需求会变化，则测试用例也应该是活的，变化的 \"及时响应变更比遵循计划更有价值\" 原则 根据程序的重要性和一旦发生故障带来的损失，来确定测试等级和测试重点 认真选择测试策略。用尽可能少的测试用例发现尽可能多的错误。测试用例不足则会导致风险的增大；测试过度导致资源的浪费。需要找到平衡点 方法选取 先关注主要功能也业务流程、业务逻辑是否正确实现，考虑场景法 需要输入数据的地方，考虑等价类划分法 在任何情况行都使用边界值法 如果程序的功能中包含输入条件的组合情况，则选取因果图和判定表法 对于配置类软件，需要考虑参数的组合情况，考虑使用正交排列法 对照程序逻辑，如果发现没有达到要求的覆盖标准。适当补充更多的测试用例 采用错误推断法，追加其他测试用例 © 2021 测试猿-猫熊 all right reserved，powered by Gitbook本文档更新于： 2021-04 "},"C4.S12.review.html":{"url":"C4.S12.review.html","title":"测试用例评审","keywords":"","body":"测试用例的评审 同行评审 \"个体和交互比过程和工具更有价值\" 由测试小组内部进行相互评审，达到思想的碰撞，通过探讨、协作完成测试用例的设计 用户评审 \"顾客的协作比合同谈判更有价值\" 如果测试是对产品的批判，则顾客指最终用户或者顾客代表 在公司内部可以是市场调查人员或者相关领域专家 如果测试是为软件开发提供帮助和支持，那么顾客就是程序员 © 2021 测试猿-猫熊 all right reserved，powered by Gitbook本文档更新于： 2021-04 "},"C5.S0.target.html":{"url":"C5.S0.target.html","title":"缺陷报告","keywords":"","body":"学习目标 知道缺陷报告的作用 能说出缺陷报告的内容 能够正确书写缺陷报告 © 2021 测试猿-猫熊 all right reserved，powered by Gitbook本文档更新于： 2021-04 "},"C5.S1.basic_concept.html":{"url":"C5.S1.basic_concept.html","title":"基础概念","keywords":"","body":"软件缺陷 定义 从内部看，软件缺陷试产品开发或者维护过程中存在的错误、毛病等各种问题 从外部看，软件缺陷是系统所需要实现的某种功能的失效或者违背 总的来说，缺陷就是问题，最终表现为所需要的功能没有完全实现，没有满足用户的需求。 具体包含（程序、数据、文档） 未达到需求规格说明书中的功能 出现了需求规格说明数中指名不会出现的错误 功能超出了需求规格说明书的范围 未达到需求规格说明书中虽然没有指明，但应该达到的目标 测试人员或者用户认为软件难以理解、不易使用、运行速度慢或者最终用户认为不好 表现形式 功能、特性没有实现或者部分实现 设计不合理，功能特性不明确，逻辑不清楚或者存在矛盾 产品实际结果和所期望的结果不一致 没有达到需求规格说明书所规定的性能指标 运行出错，中断、奔溃、界面混乱 数据不正确、精度不够，不完整，格式不统一 用户不能接受的其他问题，超时、界面丑陋 硬件或者系统软件上存在的其他问题 缺陷产生的原因 缺陷不可避免，主要原因如下 需求解释或者记录错误 用户需求定义错误 需求说明存在错误 编码说明、程序代码有无 硬件或者系统存在错误 文档错误、内容不正确、拼写错误 缺陷产生的根源 交流不充分 软件的复杂性 开发任务的错误 需求的变化 进度压力 缺陷的修复费用 © 2021 测试猿-猫熊 all right reserved，powered by Gitbook本文档更新于： 2021-04 "},"C5.S2.defect_report_intro.html":{"url":"C5.S2.defect_report_intro.html","title":"缺陷报告介绍","keywords":"","body":"缺陷报告 在测试后，如果发现缺陷，则应该进行缺陷报告。 缺陷报告的一些字段及说明 缺陷报告有如下作用： 记录测试结果 方便开发人员进行缺陷的定位 为后期统计缺陷提供依据 © 2021 测试猿-猫熊 all right reserved，powered by Gitbook本文档更新于： 2021-04 "},"C5.S3.defect_report_content.html":{"url":"C5.S3.defect_report_content.html","title":"缺陷报告内容","keywords":"","body":"缺陷的状态 状态 含义 new 新建, 缺陷的初始状态 assigned 已指派，分配给具体的开发人员 open 打开, 开发人员开始修改缺陷 fixed 修复,开发人员修改缺陷完毕 closed 回归测试通过,关闭缺陷 reopen 回归测试失败,再次打开 postpone 推迟修改 duplicate 与已提交的Defect重复 reject 拒绝修复，可能为测试人员对于需求理解错误 状态变化 new - 测试人员发现缺陷 assigned - 由开发经理或者其他人员，将修复职责指定为某位开发人员 开发人员阅读缺陷报告，可能得到如下结果 open 测试人员是正确的，准备修复 duplicate 与其他bug为同一原因，修正好一个后，这个也就修复了 reject 测试人员理解错误，其实这不是bug fixed 经过一段时间开发人员修复了bug，就会标记为此状态 postpone 小问题，目前没有时间修复 测试人员检验缺陷状态 closed 再次测试，发现错误已经修复。 closed reject的错误，经过沟通核实后，确认无需修复 reopen 原来修复后的缺陷，经过回归测试后又出现了，标记原先的缺陷为此状态 缺陷的跟踪 要点 缺陷从测试人员开始， 也应该由测试人员结束。 严重程度 严重程度分为五个等级： Fatal 致命的缺陷 造成系统或应用程序崩溃、死机、系统挂起，或造成数据丢失，主要功能完全丧失，导致本模块以及相关模块异常等问题。 Critical 严重错误的软件缺陷 系统的主要功能部分丧失、数据不能保存，系统的次要功能完全丧失。问题局限在本模块，导致模块功能失效或异常退出。 如系统资源占用过大、功能没有做完。 Major 一般的软件缺陷 次要功能没有完全实现但不影响使用。 如：提示信息不太准确，或用户界面差，操作时间长，模块功能部分失效等。 Minor 较小的软件缺陷 较小错误的软件缺陷，使操作者不方便或遇到麻烦，但它不影响功能性的操作和执行。 例如：对话框弹出位置，步骤较多，输入项太麻烦。 Enhancemental 建议问题 由问题提出人对测试对象的改进意见或测试人员提出的建议、质疑。 例如：错别字、颜色、按钮大小。 说明 严重程度的分级，并不统一，有的公司分为3个等级或者4个等级，都是可以的 优先级 级别 定义 说明 P1 立即解决 缺陷导致系统几乎不能完全运行、使用，或严重妨碍测试的执行，需立即修正、尽快修正； P2 高级优先 缺陷严重，影响测试，需要优先考虑修正，如不超过24小时修正； P3 正常级别 缺陷需要修改,只要正常排队修复就可以 P4 低优先级 缺陷可以在开发人员有时间的时间修复,若没时间可以不修正 说明 有的公司，也会把优先级分为3个或者5个，都是可以的。 表现形式 分类 说明 代码问题 不满足需求、功能实现错误；对产品或项目质量有影响的bug可统一划入； 设计缺陷 页面美观性、协调性、错别字等 用户体验 对产品、项目的建议性意见，不强制要求修改 性能问题 进行性能测试时使用，暂定：网络延时、内存问题、CPU占用、硬盘问题 安全问题 业务功能存在的安全问题 兼容问题 在部分环境中表现正常，在部分环境中表现不正常 接口问题 涉及有模块间数据传递时使用 配置问题 由于提供的配置不当或者配置不能够满足实际要求而出现的问题 其他问题 上述不能归纳进来的 © 2021 测试猿-猫熊 all right reserved，powered by Gitbook本文档更新于： 2021-04 "},"C5.S4.defect_report_write.html":{"url":"C5.S4.defect_report_write.html","title":"缺陷报告书写","keywords":"","body":"缺陷报告书写规范 标题 简短 尽量能够体现 原因和结果 准确：避免使用模糊不清的词语 便于他人理解，不要使用俚语、方言词汇 原则 完整 他人按照步骤，即可复现问题 简明 不包含夸张、啰嗦的内容 内容 测试环境描述 步骤 加上编号 一个步骤不要包含太多步骤 可能将多个步骤合为一个 可以包含 该步骤后的一个中间结果 可使用短语或者短句，不需要复杂句式 实际结果 清楚，不笼统 期望结果 根据需求文档，应该出现的结果 附件 截图、录屏、测试中需要的数据 解决方案/可能的原因（非必须） 如果测试人员能够给出解决方案则更好了。 常见错误 人称代词不明确 情绪化语言、强调符号 不确定词汇 “幽默”、“梗” 不确定：对于缺陷，测试人员至少需要再次操作，来重现缺陷 © 2021 测试猿-猫熊 all right reserved，powered by Gitbook本文档更新于： 2021-04 "},"C5.S5.defect_report_statistic.html":{"url":"C5.S5.defect_report_statistic.html","title":"缺陷报告统计","keywords":"","body":"缺陷统计 通过缺陷统计，我们可能得出以下信息 缺陷分布：找出系统的薄弱环境 缺陷状态：根据变化，检查测试和开发的工作情况 人员水平：开发人员出错的数量，测试人员测出的数量 比较历史：对人员水平有所把握 模块难度：较难的模块出问题的可能较大 修复时间：平均修复缺陷需要的时间，越短越好 未修复的缺陷数目： 作用 风险评估：能否在计划内的时间发布 缺陷原因：避免反复出现同类型的缺陷 员工技能提升：根据开发和测试人员表现出来的问题，可有针对性提升 团队配置：根据缺陷修复时间，可知道团队配合强弱 指标 单位时间（天/周）内报告的缺陷数目 单位时间（天/周）内修复的缺陷数目 累计缺陷报告数量 累计缺陷修复数量 不同严重性的缺陷数 模块与缺陷的对应关系 缺陷密度 单位 缺陷数量/kloc ( kilo lines of code) 计算 总缺陷数量 / 总代码行数 / 1000 例子 https://www.cnblogs.com/yingyingja/p/9803542.html © 2021 测试猿-猫熊 all right reserved，powered by Gitbook本文档更新于： 2021-04 "},"C5.S6.defect_report_summary.html":{"url":"C5.S6.defect_report_summary.html","title":"缺陷报告总结","keywords":"","body":"缺陷报告的原则和重要性 重要性 节省开发和测试人员的沟通时间 提高缺陷修复速度 提高测试人员的声誉 加强协同工作 原则： 5C准则 准确：每个组成部分的描述准确不会引起误解。 简洁：只包含必不可少的信息，不包括任何多余的内容。 清晰：每个组成部分的描述清晰，易于理解。 完整：包含复现该缺陷的完整步骤和其他本质信息。 一致：按照一致的格式书写全部缺陷报告。 一个缺陷一个报告 便于分配 便于验证 常见缺陷的查找方法 UI （非重点） 色彩 大小 布局 图片 字体 时间 网络传输 数据未压缩 解析困难 文字内容 描述不清 描述不正确 有语病、错别字 太复杂 乱码 容错处理 性能缺陷 花费时间长 资源占用多 卡顿 并发差 延迟高 缺陷的修复？ 不是所有的“缺陷” 都是缺陷 无法重现 或者 难以捕捉 缺陷报告中没有复现步骤 缺陷报告无法理解 极少使用的功能，或者不符合用户习惯，或者惯例 由不受信任的测试人员提出 不是所有的缺陷都会修改 上线时间由限制 不正确的操作 涉及模块太多，可能导致按下葫芦浮起瓢的情况 性价比太低 极难重现 © 2021 测试猿-猫熊 all right reserved，powered by Gitbook本文档更新于： 2021-04 "},"C5.S7.defect_manage.html":{"url":"C5.S7.defect_manage.html","title":"缺陷管理","keywords":"","body":"缺陷的管理过程（了解） CMM = Capability Maturity Model for Software = 软件能力成熟度模型 CMM/CMMI将软件过程的成熟度分为5个等级,以下是5个等级的基本特征： 初始级(initial)。 工作无序，项目进行过程中常放弃当初的计划。管理无章法，缺乏健全的管理制度。开发项目成效不稳定，项目成功主要依靠项目负责人的经验和能力，他一但离去，工作秩序面目全非。 可重复级(Repeatable) 管理制度化，建立了基本的管理制度和规程，管理工作有章可循。 初步实现标准化，开发工作比较好地按标准实施。 变更依法进行，做到基线化，稳定可跟踪，新项目的计划和管理基于过去的实践经验，具有重复以前成功项目的环境和条件。 已定义级(Defined) 开发过程，包括技术工作和管理工作，均已实现标准化、文档化。建立了完善的培训制度和专家评审制度，全部技术活动和管理活动均可控制，对项目进行中的过程、岗位和职责均有共同的理解 。 已管理级(Managed) 产品和过程已建立了定量的质量目标。开发活动中的生产率和质量是可量度的。已建立过程数据库。已实现项目产品和过程的控制。可预测过程和产品质量趋势，如预测偏差，实现及时纠正。 优化级(Optimizing) 可集中精力改进过程，采用新技术、新方法。拥有防止出现缺陷、识别薄弱环节以及加以改进的手段。可取得过程有效性的统计数据，并可据进行分析，从而得出最佳方法。 © 2021 测试猿-猫熊 all right reserved，powered by Gitbook本文档更新于： 2021-04 "}}